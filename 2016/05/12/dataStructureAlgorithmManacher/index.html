<!doctype html>
<html class="theme-next   use-motion ">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="google-site-verification" content="SxtUWZeCB1kdMgucSmFlZL9HwwJmgQHGcp9w_p4Xtgc" />
<meta name="baidu-site-verification" content="Sil1fR2zak" />



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"/>




  <link href="//fonts.googleapis.com/css?family=Lato:300,400,700,400italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">



<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=0.4.5.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="经典算法,Java," />





  <link rel="alternate" href="/atom.xml" title="技术联系你我" type="application/atom+xml" />




      <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=0.4.5.2" />






<meta name="description" content="主要内容：Manacher算法">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构经典算法-Manacher算法">
<meta property="og:url" content="http://lingdu.online/2016/05/12/dataStructureAlgorithmManacher/index.html">
<meta property="og:site_name" content="技术联系你我">
<meta property="og:description" content="主要内容：Manacher算法">
<meta property="og:image" content="http://i.imgur.com/B5rJ2QE.jpg">
<meta property="og:image" content="http://i.imgur.com/waTA5S4.jpg">
<meta property="og:image" content="http://i.imgur.com/5lp4vS0.jpg">
<meta property="og:image" content="http://i.imgur.com/2nYzpPr.jpg">
<meta property="og:image" content="http://i.imgur.com/4vGHxVI.jpg">
<meta property="og:image" content="http://i.imgur.com/lJ7fhs4.jpg">
<meta property="og:image" content="http://i.imgur.com/Nfu2mEo.jpg">
<meta property="og:updated_time" content="2016-05-14T12:57:42.143Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="数据结构经典算法-Manacher算法">
<meta name="twitter:description" content="主要内容：Manacher算法">
<meta name="twitter:image" content="http://i.imgur.com/B5rJ2QE.jpg">



<script type="text/javascript" id="hexo.configuration">
  var CONFIG = {
    scheme: 'Mist',
    sidebar: 'post',
    motion: true
  };
</script>

  <title> 数据结构经典算法-Manacher算法 | 技术联系你我 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  <!--[if lte IE 8]>
  <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'>
    <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode">
      <img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820"
           alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari."
           style='margin-left:auto;margin-right:auto;display: block;'/>
    </a>
  </div>
<![endif]-->
  






  <div class="container one-column page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">技术联系你我</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu ">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home fa-fw"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-th fa-fw"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive fa-fw"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-tags fa-fw"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-user fa-fw"></i> <br />
            
            关于
          </a>
        </li>
      

      
      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div id="content" class="content">
          

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                数据结构经典算法-Manacher算法
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2016-05-12T15:08:30+08:00" content="2016-05-12">
              2016-05-12
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/数据结构/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/12/dataStructureAlgorithmManacher/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/12/dataStructureAlgorithmManacher/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        <span itemprop="articleBody"><p>主要内容：Manacher算法<br><a id="more"></a></p>
<p>精华篇</p>
<h1 id="1-Manacher算法"><a href="#1-Manacher算法" class="headerlink" title="1. Manacher算法"></a>1. Manacher算法</h1><p><strong>算法描述</strong></p>
<p>给定一个字符串str，返回str中最长回文子串的长度。</p>
<p><strong>例如：</strong></p>
<p>str=“123”，其中的最长回文子串为“1”，“2”或者“3”，所以返回 1。</p>
<p>str=“abc1234321ab”，其中的最长回文子串为 “1234321”，所以返回 7。</p>
<p><strong>要求</strong></p>
<p>如果str的长度为 N，要求解决该问题的算法复杂度达到 O(N)。</p>
<p><strong>求解过程</strong></p>
<p>Manacher算法是由Glenn Manacher于1975年首次发明的。Manacher算法解决的问题是在线性时间内找到一个字符串的最长回文子串。</p>
<p>首先我们引入一个很好理解的方法。从左到右遍历字符串，遍历到每个字符的时候，都看看以这个字符作为中心能够产生多大的回文字符串。比如 str=“abacaba”，以str[0]==’a’为中心的回文字符串最大长度为1，以str[1]==’b’为中心的回文字符串最大长度为3，<strong>……</strong>其中最大的回文子串是以str[3]==’c’为中心的时候。这种方法非常容易理解，只需要解决奇回文和偶回文寻找方式的不同就可以。比如“121”是奇回文，有确定的轴’2’。“1221”是偶回文，没有确定的实轴，回文的虚轴是 “22” 中间的位置。但是这种方法有明显的问题，之前遍历过的字符无法指导后续的遍历过程，对每一个字符来说都是从自己的位置向两边 <strong>扩</strong> 出去检查是否有回文序列。这样对每一个字符来说，向外扩的代价都是一个级别的。举一个极端的例子 “aaaaaaaaaaaaa”对每一个字符’a’来讲，都是扩到边界才会停止，所以每一个字符扩出去检查的代价都是 O(N)，对于整个字符串来讲总的时间复杂度就是 O(N<em>N)。Manacher算法可以做到 O(N) 的时间复杂度，精髓就是之前字符的 <strong>扩</strong> 过程，可以指导后面字符的 <strong>扩</strong> 过程，使得每次的 <em>*扩</em></em> 过程都不是从无开始。以下是Manacher算法解决原问题的过程：</p>
<h2 id="1-扩充字符串"><a href="#1-扩充字符串" class="headerlink" title="1. 扩充字符串"></a>1. 扩充字符串</h2><p>因为奇回文和偶回文在判断时比较麻烦，所以对str进行处理，把每一个字符的开头、中间和结尾都插入一个特殊的字符’#’来得到一个新的字符串数组。比如str=“bcbaa”，处理后为 “#b#c#b#a#a#”，然后从每个字符左右扩出去的方式找最大回文子串就方便很多，解决了奇和偶回文的差异性问题。插入的这个辅助字符不一定是’#’，其他的任何字符都可以，单纯是辅助的作用。具体的处理过程如下代码的manacherString方法所示:</p>
<pre><code>public char[] manacherString(String str) {
        char[] charArr = str.toCharArray();
        char[] res = new char[str.length() * 2 + 1];
        int index = 0;
        for (int i=0; i != res.length; i++) {
                res[i] = (i &amp; 1) == 0 ? &apos;#&apos; : charArr[index++];
        }
        return res;
}
</code></pre><h2 id="2-三个重要的辅助变量"><a href="#2-三个重要的辅助变量" class="headerlink" title="2. 三个重要的辅助变量"></a>2. 三个重要的辅助变量</h2><p>假设str处理之后的字符串记为charrArr。对每个字符（包括特殊字符）都进行“优化后”的扩过程。在介绍“优化后”的扩过程之前，先解释如下三个辅助变量的意义。</p>
<h3 id="1-数组pArr"><a href="#1-数组pArr" class="headerlink" title="1. 数组pArr"></a>1. 数组pArr</h3><p>数组pArr的长度与charArr长度一样。pArr[i]的意义是以 i 位置上的字符（charArr[i]）作为回文中心的情况下，扩出去得到的最大回文半径是多少。举个例子来说明，对 “#c#a#b#a#c#”来说，pArr[0..10]为[1,2,1,2,1,6,1,2,1,2,1]。我们的整个过程就是在从左到右的遍历过程中，依次计算每个位置的最大回文半径值。</p>
<h3 id="2-整数pR"><a href="#2-整数pR" class="headerlink" title="2. 整数pR"></a>2. 整数pR</h3><p>这个变量的意义是之前遍历的所有字符的所有回文半径中，最右即将到达的位置。还是以 “#c#a#b#a#c#”为例子来说，还没遍历之前 pR 的初始值设置为 -1。charArr[0]==’#’的回文半径为1，所以目前回文半径向右智能扩到位置 0，回文半径最右即将到达的位置为 1（pR=1）。charArr[1]==’c’的回文半径为 2，此时所有的回文半径向右能扩到位置 2，所以回文半径最右即将到达的位置变为 3（pR=3）。charArr[2]==’#’的回文半径为 1，所以位置 2 向右还是只能扩到位置 2，回文半径最右即将到达的位置不变，仍是 3（pR=3）。charArr[3]==’a’的回文半径为 2，所以位置 3 向右可以扩展到位置 4，所以回文半径最右即将到达的位置变为 5（pR=5）。charArr[4]==’#’的回文半径为 1，所以位置 4 向右依然只能扩到位置 4，回文半径最右即将到达的位置不变为 5（pR=5)。charArr[5]==’b’的回文半径为 6，所以位置 5向右能扩展到位置 10，回文半径最右即将到达的位置变为 11（pR=11）。此时已经到达整个字符数组的结尾，所以之后的过程中pR将不再变化。换句话说，pR就是遍历的所有字符中向右扩出来的最大边界。只要右边界更往右，pR就更新，pR一旦有更新，最大的回文半径就有可能发生变化。</p>
<h3 id="3-整数index"><a href="#3-整数index" class="headerlink" title="3. 整数index"></a>3. 整数index</h3><p>这个变量表示最近一次更新pR时，那个回文中心的位置。还是以刚刚的例子来说，遍历到charArr[0]时 pR更新，index就更新为 0。遍历到charArr[1]时 pR更新，index就更新为 1 <strong>……</strong>遍历到charArr[5]时 pR更新，index就更新为 5。之后的过程中，pR将不再更新，所以index就一直为5。</p>
<h2 id="3-计算pR数组每个位置的值"><a href="#3-计算pR数组每个位置的值" class="headerlink" title="3. 计算pR数组每个位置的值"></a>3. 计算pR数组每个位置的值</h2><p>只要能够从左到右依次算出数组 pR每个位置的值，最大的那个值实际上就是处理后的charArr中最大的回文半径，根据最大的回文半径，再对应回原字符串的话，整个问题就解决了。</p>
<p><strong>（1）</strong>假设现在计算到位置 i 的字符charArr[i]，在 i 之前位置的计算过程中，都会不断地更新pR和index的值，即位置 i 之前的index这个回文中心扩出了一个目前最右的回文边界pR。</p>
<p><strong>（2）</strong>如果pR-1 位置没有包住当前的 i 位置。比如 “#c#a#b#a#c#”，计算到charArr[1]==’c’时，pR为 1。也就是说，右边界在 1 位置，1 位置为最右回文半径即将到达但还没到达的位置，所以当前的pR-1 位置没有包住当前的 i 位置。此时和普通的做法一样，从 i 位置字符开始，向左右两侧扩出去检查，此时的 <strong>扩</strong> 过程没有获得加速。</p>
<p><strong>（3）</strong>如果pR-1 位置包住了当前的 i 位置。比如 “#c#a#b#a#c#”，计算到charArr[6..10]时，pR都为 11，此时pR-1包住了位置 6~10。这种情况下，检查过程是可以获得优化的，这就是manacher算法的核心内容，如下图1所示：</p>
<p><img src="http://i.imgur.com/B5rJ2QE.jpg" alt="Fig1"></p>
<p>在图1中，位置 i 是要计算回文半径（pArr[i]）的位置。pR-1位置此时是包住位置 i 的。同时根据 index 的定义，index 是pR更新时那个回文中心的位置，所以如果pR-1位置以index为中心对称，即图1中的“左大”位置，那么从“左大”位置到pR-1位置一定是以index为中心的回文串，我们把这个回文串称作大回文串，同时把pR-1位置称为“右大”位置。既然回文半径数组pArr是从左到右计算的，所以位置 i 之前的所有位置都已经计算过回文半径。假设位置 i 以index为中心向左对称过去的位置为 i’，那么位置 i’的回文半径也是计算过的。那么以 i’ 为中心的最大回文串大小（pArr[i’])必然只有三种情况，我们依次来分析下面三种情况。假设以 i’为中心的最大回文串的左边界和右边界分别记为“左小”和“右小”。</p>
<p><strong>（情况一）</strong><br>“左小”和“右小”完全在“左大”和“右大”内部，即以 i’为中心的最大回文串完全在以index为中心的最大回文串的内部，如图2所示：</p>
<p><img src="http://i.imgur.com/waTA5S4.jpg" alt="Fig2"></p>
<p>图2中，a’是“左小”位置的前一个字符，b’是“右小”位置的后一个字符，b 是 b’以index为中心的对称字符，a 是 a’以index为中心的对称字符。“左小’”是“左小”以index为中心的对称位置，“右小’”是“右小”以index为中心的对称位置。如果处在情况一下，那么以位置 i为中心的最大回文串可以直接确定，就是从“右小’”到“左小’”这一段。这是什么愿意呢？首先，“左小”到“右小”这一段如果以index为回文中心，对应过去就是“右小’”到“左小’”这一段，那么“右小’”到“左小’”这一段就完全是“左小”到“右小”这一段的逆序。同时有“左小”到“右小”这一段以 i’为回文中心的回文串，所以“右小’”到“左小’”这一段一定也是回文串，也就是说，以位置 i 为中心的最大回文串起码是“右小’”到“左小’”这一段。另外，以位置 i’为中心的最大回文串只是“右小”到“左小”这一段，说明 a’!=b’。那么与a’相等的a也必然不等于与b’相等的b，所以a!=b，从而说明以位置 i 为中心的最大回文串就是“右小’”到“左小’”这一段，而不会扩地更大。情况一举例如图3所示：</p>
<p><img src="http://i.imgur.com/5lp4vS0.jpg" alt="Fig3"></p>
<p><strong>（情况二）</strong>，“左小”和“右小”的左侧部分在“左大”和“右大”的外部，如图4所示：</p>
<p><img src="http://i.imgur.com/2nYzpPr.jpg" alt="Fig4"></p>
<p>图4中，a 是“左大”位置的前一个字符，d 是“右大”位置的后一个字符，“左大’”是“左大”以位置 i’为中心的对称位置，“右大’”“右大”以位置 i 为中心的对称位置，b是“左大’”位置的后一个字符，c是“右大’”位置的前一个字符。如果处在情况二下，那么以位置 i 为中心的最大回文串可以直接确定，就是从“右大’”到“右大”这一段。这是什么原因呢？首先，“左大”到“左大’”这一段和“右大’”到“右大”这一段是关于index对称的，所以“右大’”到“右大”这一段是“左大”到“左大’”这一段的逆序。同时“左小”到“右小”这一段是回文串（以 i’位置为中心），那么“左大”到“左大’”这一段也是回文串，所以“左大”到“左大’”这一段的逆序也是回文串，所以“右大’”到“右大”这一段一定是回文串。也就是说，以位置 i 为中心的最大回文串起码是“右大’”到“右大”这一段。另外，“左小”到“右小”这一段是回文串，说明 a==b，b和c关于index对称，说明 b==c，“左大”到“右大”这一段没有扩地更大，说明 a!=d，所以 d!=c。说明以位置 i 为中心的最大回文串就是“右大’”到“右大”这一段，而不会扩地更大。情况二举例如图5所示：</p>
<p><img src="http://i.imgur.com/4vGHxVI.jpg" alt="Fig5"></p>
<p><strong>（情况三）</strong><br>“左小”和“左大”是同一位置，即以 i’ 为中心的最大回文串压在了以index为中心的最大回文串的边界上，如图6所示：</p>
<p><img src="http://i.imgur.com/lJ7fhs4.jpg" alt="Fig6"></p>
<p>在图6中“左大”和“左小”的位置重叠，“右小’”是“右小”位置以index为中心的对称位置，“右大’”是“右大”位置以 i 为中心的对称位置，可以容易证明“右小’”和“右大’”的位置也重叠。如果处在情况三下，那么以位置 i 为中心的最大回文串起码是“右大’”和“右大”这一段，但可能会扩地更大。因为“右大’”和“右大”这一段是“左小”和“右小”这一段以index为中心对称过去的，所以两段互为逆序关系，同时“左小”和“右小”这一段又是回文串，所以“右大’”和“右大”这一段肯定是回文串，但以位置 i 为中心的最大回文串是可能扩地更大的。比如图7的例子所示：</p>
<p><img src="http://i.imgur.com/Nfu2mEo.jpg" alt="Fig7"></p>
<p>图7中，以位置 i 为中心的最大回文串起码是“右大’”到“右大”这一段，但可以扩地更大。说明在情况三下，扩出去的过程可以得到优化，但还是无法避免扩出去的检查。</p>
<h2 id="4-计算pArr数组"><a href="#4-计算pArr数组" class="headerlink" title="4. 计算pArr数组"></a>4. 计算pArr数组</h2><p>按照步骤3的逻辑从左到右计算出pArr数组，计算完成后再遍历一遍pArr数组，找出最大的回文半径，假设位置 i 的回文半径最大，即pArr[i]==max。但是max只是charArr的最大回文半径，还得对应回原来的字符串，求出最大回文半径的长度（其实就是max-1）。比如元字符串为 “121”，处理成charArr后为 “#1#2#1#”。在charArr中位置3的回文半径最大，最大值为4，即（pArr[3]==4），对应原字符串的最大回文子串的长度为4-1=3。</p>
<h2 id="5-Manacher算法时间复杂度证明"><a href="#5-Manacher算法时间复杂度证明" class="headerlink" title="5. Manacher算法时间复杂度证明"></a>5. Manacher算法时间复杂度证明</h2><p>虽然我们可以很明显的看到Manacher的算法与普通算法相比，在扩出去检查这一行为上有明显的优化，但是如何证明该算法的世家复杂度就是 O(N) 呢？关键之处在于估算扩出去检查这一行为发生的数量。原字符串在处理后的长度由 N 变为 2N ，从步骤3的主要逻辑来看，要么在计算一个位置的回文半径时完全不需要扩出去检查，比如步骤3中的（3）介绍的情况一和情况二，都可以直接获得位置 i 的回文半径长度；要么每一次扩出去检查都会导致pR变量的更新，比如步骤3中的（2）和（3）介绍的情况三，扩出去检查时都让回文半径到达更右的位置。当然会使pR更新。然而pR最多从 -1 增加到 2N(右边界)，并且从来不减小，所以扩出去检查的次数就是 O(N)级别的。所以Manacher算法的时间复杂度是 O(N) 。具体的实现代码如下maxLcpsLength方法所示：</p>
<pre><code>public static int maxLcpsLength(String str) {
    if (str == null || str.length() == 0) {
        return 0;
    }
    char[] charArr = manacherString(str);
    int[] pArr = new int[charArr.length];
    int index = -1;
    int pR = -1;
    int max = Integer.MIN_VALUE;
    for (int i = 0; i != charArr.length; i++) {
        pArr[i] = pR &gt; i ? Math.min(pArr[2 * index - i], pR - i) : 1;
        while (i + pArr[i] &lt; charArr.length &amp;&amp; i - pArr[i] &gt; -1) {
            if (charArr[i + pArr[i]] == charArr[i - pArr[i]])
                pArr[i]++;
            else {
                break;
            }
        }
        if (i + pArr[i] &gt; pR) {
            pR = i + pArr[i];
            index = i;
        }
        max = Math.max(max, pArr[i]);
    }
    return max - 1;
}
</code></pre><p>整个问题的实现源码如下所示：</p>
<pre><code>public class Problem_ManacherAlgorithm {

    public static char[] manacherString(String str) {
        char[] charArr = str.toCharArray();
        char[] res = new char[str.length() * 2 + 1];
        int index = 0;
        for (int i = 0; i != res.length; i++) {
            res[i] = (i &amp; 1) == 0 ? &apos;#&apos; : charArr[index++];
        }
        return res;
    }

    public static int maxLcpsLength(String str) {
        if (str == null || str.length() == 0) {
            return 0;
        }
        char[] charArr = manacherString(str);
        int[] pArr = new int[charArr.length];
        int index = -1;
        int pR = -1;
        int max = Integer.MIN_VALUE;
        for (int i = 0; i != charArr.length; i++) {
            pArr[i] = pR &gt; i ? Math.min(pArr[2 * index - i], pR - i) : 1;
            while (i + pArr[i] &lt; charArr.length &amp;&amp; i - pArr[i] &gt; -1) {
                if (charArr[i + pArr[i]] == charArr[i - pArr[i]])
                    pArr[i]++;
                else {
                    break;
                }
            }
            if (i + pArr[i] &gt; pR) {
                pR = i + pArr[i];
                index = i;
            }
            max = Math.max(max, pArr[i]);
        }
        return max - 1;
    }

    public static void main(String[] args) {
        String str1 = &quot;abc1234321ab&quot;;
        System.out.println(maxLcpsLength(str1));

    }

}
</code></pre></span>
      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/经典算法/" rel="tag">#经典算法</a>
          
            <a href="/tags/Java/" rel="tag">#Java</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/05/12/dataStructureAlgorithmKMP/" rel="next" title="数据结构经典算法-KMP算法">
                <i class="fa fa-chevron-left"></i> 数据结构经典算法-KMP算法
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2016/05/13/binaryTreeErgodic/" rel="prev" title="二叉树遍历">
                二叉树遍历 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
        <div class="ds-share flat" data-thread-key="2016/05/12/dataStructureAlgorithmManacher/"
     data-title="数据结构经典算法-Manacher算法"
     data-content=""
     data-url="http://lingdu.online/2016/05/12/dataStructureAlgorithmManacher/">
  <div class="ds-share-inline">
    <ul  class="ds-share-icons-16">

      <li data-toggle="ds-share-icons-more"><a class="ds-more" href="javascript:void(0);">分享到：</a></li>
      <li><a class="ds-weibo" href="javascript:void(0);" data-service="weibo">微博</a></li>
      <li><a class="ds-qzone" href="javascript:void(0);" data-service="qzone">QQ空间</a></li>
      <li><a class="ds-qqt" href="javascript:void(0);" data-service="qqt">腾讯微博</a></li>
      <li><a class="ds-wechat" href="javascript:void(0);" data-service="wechat">微信</a></li>

    </ul>
    <div class="ds-share-icons-more">
    </div>
  </div>
</div>
      
    </div>
  </div>


        </div>

        


        
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="2016/05/12/dataStructureAlgorithmManacher/"
           data-title="数据结构经典算法-Manacher算法" data-url="http://lingdu.online/2016/05/12/dataStructureAlgorithmManacher/">
      </div>
    
  </div>


      </div>

      
        
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" src="/images/lingdu.jpg" alt="LINGDU" itemprop="image"/>
          <p class="site-author-name" itemprop="name">LINGDU</p>
        </div>
        <p class="site-description motion-element" itemprop="description">绝对零度的世界——有的只是纯粹</p>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">18</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            <a href="/categories">
              <span class="site-state-item-count">11</span>
              <span class="site-state-item-name">分类</span>
              </a>
          </div>

          <div class="site-state-item site-state-tags">
            <a href="/tags">
              <span class="site-state-item-count">20</span>
              <span class="site-state-item-name">标签</span>
              </a>
          </div>

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
        </div>

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc-indicator-top post-toc-indicator">
            <i class="fa fa-angle-double-up"></i>
          </div>
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-Manacher算法"><span class="nav-number">1.</span> <span class="nav-text">1. Manacher算法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-扩充字符串"><span class="nav-number">1.1.</span> <span class="nav-text">1. 扩充字符串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-三个重要的辅助变量"><span class="nav-number">1.2.</span> <span class="nav-text">2. 三个重要的辅助变量</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-数组pArr"><span class="nav-number">1.2.1.</span> <span class="nav-text">1. 数组pArr</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-整数pR"><span class="nav-number">1.2.2.</span> <span class="nav-text">2. 整数pR</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-整数index"><span class="nav-number">1.2.3.</span> <span class="nav-text">3. 整数index</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-计算pR数组每个位置的值"><span class="nav-number">1.3.</span> <span class="nav-text">3. 计算pR数组每个位置的值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-计算pArr数组"><span class="nav-number">1.4.</span> <span class="nav-text">4. 计算pArr数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-Manacher算法时间复杂度证明"><span class="nav-number">1.5.</span> <span class="nav-text">5. Manacher算法时间复杂度证明</span></a></li></ol></li></ol></div>
            
          </div>
          <div class="post-toc-indicator-bottom post-toc-indicator">
            <i class="fa fa-angle-double-down"></i>
          </div>
        </section>
      

    </div>
  </aside>


      
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="icon-next-heart fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">LINGDU</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>



      </div>
    </footer>

    <div class="back-to-top"></div>
  </div>

  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  

  
    

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"utterzero"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>
    
     


    
  

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/fancy-box.js?v=0.4.5.2"></script>


  <script type="text/javascript" src="/js/helpers.js?v=0.4.5.2"></script>
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>
<script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

<script type="text/javascript" src="/js/motion.js?v=0.4.5.2" id="motion.global"></script>


  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  
<script type="text/javascript" src="/js/bootstrap.scrollspy.js?v=0.4.5.2" id="bootstrap.scrollspy.custom"></script>


<script type="text/javascript" id="sidebar.toc.highlight">
  $(document).ready(function () {
    var tocSelector = '.post-toc';
    var $tocSelector = $(tocSelector);
    var activeCurrentSelector = '.active-current';

    $tocSelector
      .on('activate.bs.scrollspy', function () {
        var $currentActiveElement = $(tocSelector + ' .active').last();

        removeCurrentActiveClass();
        $currentActiveElement.addClass('active-current');

        $tocSelector[0].scrollTop = $currentActiveElement.position().top;
      })
      .on('clear.bs.scrollspy', function () {
        removeCurrentActiveClass();
      });

    function removeCurrentActiveClass () {
      $(tocSelector + ' ' + activeCurrentSelector)
        .removeClass(activeCurrentSelector.substring(1));
    }

    function processTOC () {
      getTOCMaxHeight();
      toggleTOCOverflowIndicators();
    }

    function getTOCMaxHeight () {
      var height = $('.sidebar').height() -
                   $tocSelector.position().top -
                   $('.post-toc-indicator-bottom').height();

      $tocSelector.css('height', height);

      return height;
    }

    function toggleTOCOverflowIndicators () {
      tocOverflowIndicator(
        '.post-toc-indicator-top',
        $tocSelector.scrollTop() > 0 ? 'show' : 'hide'
      );

      tocOverflowIndicator(
        '.post-toc-indicator-bottom',
        $tocSelector.scrollTop() >= $tocSelector.find('ol').height() - $tocSelector.height() ? 'hide' : 'show'
      )
    }

    $(document).on('sidebar.motion.complete', function () {
      processTOC();
    });

    $('body').scrollspy({ target: tocSelector });
    $(window).on('resize', function () {
      if ( $('.sidebar').hasClass('sidebar-active') ) {
        processTOC();
      }
    });

    onScroll($tocSelector);

    function onScroll (element) {
      element.on('mousewheel DOMMouseScroll', function (event) {
          var oe = event.originalEvent;
          var delta = oe.wheelDelta || -oe.detail;

          this.scrollTop += ( delta < 0 ? 1 : -1 ) * 30;
          event.preventDefault();

          toggleTOCOverflowIndicators();
      });
    }

    function tocOverflowIndicator (indicator, action) {
      var $indicator = $(indicator);
      var opacity = action === 'show' ? 1 : 0;
      $indicator.velocity ?
        $indicator.velocity('stop').velocity({
          opacity: opacity
        }, { duration: 100 }) :
        $indicator.stop().animate({
          opacity: opacity
        }, 100);
    }

  });
</script>

<script type="text/javascript" id="sidebar.nav">
  $(document).ready(function () {
    var html = $('html');
    var TAB_ANIMATE_DURATION = 200;
    var hasVelocity = $.isFunction(html.velocity);

    $('.sidebar-nav li').on('click', function () {
      var item = $(this);
      var activeTabClassName = 'sidebar-nav-active';
      var activePanelClassName = 'sidebar-panel-active';
      if (item.hasClass(activeTabClassName)) {
        return;
      }

      var currentTarget = $('.' + activePanelClassName);
      var target = $('.' + item.data('target'));

      hasVelocity ?
        currentTarget.velocity('transition.slideUpOut', TAB_ANIMATE_DURATION, function () {
          target
            .velocity('stop')
            .velocity('transition.slideDownIn', TAB_ANIMATE_DURATION)
            .addClass(activePanelClassName);
        }) :
        currentTarget.animate({ opacity: 0 }, TAB_ANIMATE_DURATION, function () {
          currentTarget.hide();
          target
            .stop()
            .css({'opacity': 0, 'display': 'block'})
            .animate({ opacity: 1 }, TAB_ANIMATE_DURATION, function () {
              currentTarget.removeClass(activePanelClassName);
              target.addClass(activePanelClassName);
            });
        });

      item.siblings().removeClass(activeTabClassName);
      item.addClass(activeTabClassName);
    });

    $('.post-toc a').on('click', function (e) {
      e.preventDefault();
      var targetSelector = escapeSelector(this.getAttribute('href'));
      var offset = $(targetSelector).offset().top;
      hasVelocity ?
        html.velocity('stop').velocity('scroll', {
          offset: offset  + 'px',
          mobileHA: false
        }) :
        $('html, body').stop().animate({
          scrollTop: offset
        }, 500);
    });

    // Expand sidebar on post detail page by default, when post has a toc.
    motionMiddleWares.sidebar = function () {
      var $tocContent = $('.post-toc-content');
      if (CONFIG.sidebar === 'post') {
        if ($tocContent.length > 0 && $tocContent.html().trim().length > 0) {
          displaySidebar();
        }
      }
    };
  });
</script>



  <script type="text/javascript" src="/js/bootstrap.js"></script>

  
  

  
  

</body>
</html>
